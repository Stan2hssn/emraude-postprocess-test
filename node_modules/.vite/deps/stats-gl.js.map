{
  "version": 3,
  "sources": ["../../.pnpm/stats-gl@3.6.0_three@0.178.0/node_modules/stats-gl/lib/panel.ts", "../../.pnpm/stats-gl@3.6.0_three@0.178.0/node_modules/stats-gl/lib/panelVsync.ts", "../../.pnpm/stats-gl@3.6.0_three@0.178.0/node_modules/stats-gl/lib/main.ts"],
  "sourcesContent": ["class Panel {\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D | null;\n    name: string;\n    fg: string;\n    bg: string;\n    gradient: CanvasGradient | null;\n    id: number = 0;\n    PR: number;\n    WIDTH: number;\n    HEIGHT: number;\n    TEXT_X: number;\n    TEXT_Y: number;\n    GRAPH_X: number;\n    GRAPH_Y: number;\n    GRAPH_WIDTH: number;\n    GRAPH_HEIGHT: number;\n\n    constructor(name: string, fg: string, bg: string) {\n        this.name = name;\n        this.fg = fg;\n        this.bg = bg;\n        this.gradient = null;\n        this.PR = Math.round(window.devicePixelRatio || 1);\n\n        this.WIDTH = 90 * this.PR;\n        this.HEIGHT = 48 * this.PR;\n        this.TEXT_X = 3 * this.PR;\n        this.TEXT_Y = 2 * this.PR;\n        this.GRAPH_X = 3 * this.PR;\n        this.GRAPH_Y = 15 * this.PR;\n        this.GRAPH_WIDTH = 84 * this.PR;\n        this.GRAPH_HEIGHT = 30 * this.PR;\n\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.WIDTH;\n        this.canvas.height = this.HEIGHT;\n        this.canvas.style.width = '90px';\n        this.canvas.style.height = '48px';\n        this.canvas.style.position = 'absolute';\n        this.canvas.style.cssText = 'width:90px;height:48px;background-color: transparent !important;';\n\n        this.context = this.canvas.getContext('2d');\n\n        this.initializeCanvas();\n    }\n\n    private createGradient(): CanvasGradient {\n        if (!this.context) throw new Error('No context');\n\n        const gradient = this.context.createLinearGradient(\n            0,\n            this.GRAPH_Y,\n            0,\n            this.GRAPH_Y + this.GRAPH_HEIGHT\n        );\n\n        let startColor: string;\n        const endColor: string = this.fg;\n\n        switch (this.fg.toLowerCase()) {\n            case '#0ff':\n                startColor = '#006666';\n                break;\n            case '#0f0':\n                startColor = '#006600';\n                break;\n            case '#ff0':\n                startColor = '#666600';\n                break;\n            case '#e1e1e1':\n                startColor = '#666666';\n                break;\n            default:\n                startColor = this.bg;\n                break;\n        }\n\n        gradient.addColorStop(0, startColor);\n        gradient.addColorStop(1, endColor);\n\n        return gradient;\n    }\n\n    public initializeCanvas() {\n        if (!this.context) return;\n\n        this.context.imageSmoothingEnabled = false;\n\n        this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';\n        this.context.textBaseline = 'top';\n\n        this.gradient = this.createGradient();\n\n        this.context.fillStyle = this.bg;\n        this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);\n\n        this.context.fillStyle = this.fg;\n        this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y);\n\n\n        this.context.fillStyle = this.bg;\n        this.context.globalAlpha = 0.9;\n        this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);\n    }\n\n    // Update only text portion\n    public update(value: number, maxValue: number, decimals: number = 0) {\n        if (!this.context || !this.gradient) return;\n\n        const min = Math.min(Infinity, value);\n        const max = Math.max(maxValue, value);\n\n        // Clear only the text area (from top to GRAPH_Y)\n        this.context.globalAlpha = 1;\n        this.context.fillStyle = this.bg;\n        this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);\n\n        // Draw text\n        this.context.fillStyle = this.fg;\n        this.context.fillText(\n            `${value.toFixed(decimals)} ${this.name} (${min.toFixed(decimals)}-${parseFloat(max.toFixed(decimals))})`,\n            this.TEXT_X,\n            this.TEXT_Y\n        );\n    }\n\n    // Update only graph portion\n    public updateGraph(valueGraph: number, maxGraph: number) {\n        if (!this.context || !this.gradient) return;\n\n        // Handle zero values appropriately\n        if (valueGraph === 0 && maxGraph === 0) {\n            maxGraph = 1; // Prevent division by zero\n        }\n\n        // Ensure maxGraph is valid and values are positive\n        maxGraph = Math.max(maxGraph, valueGraph, 0.1);\n        valueGraph = Math.max(valueGraph, 0);\n\n        // Ensure all coordinates are rounded to avoid sub-pixel rendering\n        const graphX = Math.round(this.GRAPH_X);\n        const graphY = Math.round(this.GRAPH_Y);\n        const graphWidth = Math.round(this.GRAPH_WIDTH);\n        const graphHeight = Math.round(this.GRAPH_HEIGHT);\n        const pr = Math.round(this.PR);\n\n        // Shift the graph left\n        this.context.drawImage(\n            this.canvas,\n            graphX + pr,\n            graphY,\n            graphWidth - pr,\n            graphHeight,\n            graphX,\n            graphY,\n            graphWidth - pr,\n            graphHeight\n        );\n\n        // Clear only the new column area\n        this.context.fillStyle = this.bg;\n        this.context.fillRect(\n            graphX + graphWidth - pr,\n            graphY,\n            pr,\n            graphHeight\n        );\n\n        // Calculate column height\n        const columnHeight = Math.min(\n            graphHeight,\n            Math.round(valueGraph / maxGraph * graphHeight)\n        );\n\n        // Draw the gradient column\n        if (columnHeight > 0) {\n            this.context.globalAlpha = 0.9;\n            this.context.fillStyle = this.gradient;\n            this.context.fillRect(\n                graphX + graphWidth - pr,\n                graphY + (graphHeight - columnHeight),\n                pr,\n                columnHeight\n            );\n        }\n\n        this.context.globalAlpha = 1;\n    }\n}\n\nexport { Panel };", "import { Panel } from './panel';\n\nclass PanelVSync extends Panel {\n    private readonly SMALL_HEIGHT: number;\n    private vsyncValue: number = 0;\n\n    constructor(name: string, fg: string, bg: string) {\n        super(name, fg, bg);\n\n        // Redefine dimensions for a smaller panel\n        this.SMALL_HEIGHT = 9 * this.PR; // Smaller height\n        this.HEIGHT = this.SMALL_HEIGHT;\n        this.WIDTH = 35 * this.PR; // Smaller width\n        this.TEXT_Y = 0 * this.PR; // Adjust text position\n\n        // Resize the canvas\n        this.canvas.height = this.HEIGHT;\n        this.canvas.width = this.WIDTH;\n        this.canvas.style.height = '9px'; // Match the new height\n        this.canvas.style.width = '35px'; // Match the new width\n        // Style for overlay positioning\n        this.canvas.style.cssText = `\n            width: 35px;\n            height: 9px;\n            position: absolute;\n            top: 0;\n            left: 0;\n            background-color: transparent !important;\n            pointer-events: none;\n        `;\n\n        // Reinitialize with new dimensions\n        this.initializeCanvas();\n    }\n\n    public initializeCanvas() {\n        if (!this.context) return;\n\n        this.context.imageSmoothingEnabled = false;\n\n        // Larger font for better visibility\n        this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';\n        this.context.textBaseline = 'top';\n        this.context.globalAlpha = 1;\n    }\n\n    // Override update for VSync-specific display\n    public update(value: number, _maxValue: number, _decimals: number = 0) {\n        if (!this.context) return;\n\n        this.vsyncValue = value;\n\n        this.context.clearRect(0, 0, this.WIDTH, this.HEIGHT);\n        // Draw VSync text\n        this.context.globalAlpha = 1;\n        this.context.fillStyle = this.bg;\n        this.context.fillText(\n            `${value.toFixed(0)}Hz`,\n            this.TEXT_X,\n            this.TEXT_Y\n        );\n    }\n\n    // Override updateGraph to do nothing (we don't need a graph for VSync)\n    public updateGraph(_valueGraph: number, _maxGraph: number) {\n        // No graph needed for VSync display\n        return;\n    }\n\n    // Method to set the offset position relative to parent panel\n    public setOffset(x: number, y: number) {\n        this.canvas.style.transform = `translate(${x}px, ${y}px)`;\n    }\n}\n\nexport { PanelVSync };", "import type * as THREE from 'three';\nimport { Panel } from './panel';\nimport { PanelVSync } from './panelVsync';\n\ninterface StatsOptions {\n  trackGPU?: boolean;\n  trackCPT?: boolean;\n  trackHz?: boolean;\n  logsPerSecond?: number;\n  graphsPerSecond?: number;\n  samplesLog?: number;\n  samplesGraph?: number;\n  precision?: number;\n  minimal?: boolean;\n  horizontal?: boolean;\n  mode?: number;\n}\n\ninterface QueryInfo {\n  query: WebGLQuery;\n}\n\ninterface AverageData {\n  logs: number[];\n  graph: number[];\n}\n\n\ninterface VSyncInfo {\n  refreshRate: number;\n  frameTime: number;\n}\n\n\ninterface InfoData {\n  render: {\n    timestamp: number;\n  };\n  compute: {\n    timestamp: number;\n  };\n}\n\nclass Stats {\n  public dom: HTMLDivElement;\n  public mode: number;\n  public horizontal: boolean;\n  public minimal: boolean;\n  public trackGPU: boolean;\n  public trackHz: boolean;\n  public trackCPT: boolean;\n  public samplesLog: number;\n  public samplesGraph: number;\n  public precision: number;\n  public logsPerSecond: number;\n  public graphsPerSecond: number;\n\n  public gl: WebGL2RenderingContext | null = null;\n  public ext: any | null = null;\n  public info?: InfoData;\n  private activeQuery: WebGLQuery | null = null;\n  private gpuQueries: QueryInfo[] = [];\n  private threeRendererPatched = false;\n\n  private beginTime: number;\n  private prevCpuTime: number;\n  private frameTimes: number[] = [];  // Store frame timestamps\n\n  private renderCount = 0;\n\n  private totalCpuDuration = 0;\n  private totalGpuDuration = 0;\n  private totalGpuDurationCompute = 0;\n\n  private _panelId: number;\n  private fpsPanel: Panel;\n  private msPanel: Panel;\n  private gpuPanel: Panel | null = null;\n  private gpuPanelCompute: Panel | null = null;\n  private vsyncPanel: PanelVSync | null = null;\n\n  public averageFps: AverageData = { logs: [], graph: [] };\n  public averageCpu: AverageData = { logs: [], graph: [] };\n  public averageGpu: AverageData = { logs: [], graph: [] };\n  public averageGpuCompute: AverageData = { logs: [], graph: [] };\n\n  private updateCounter = 0;\n  private prevGraphTime: number;\n  private lastMin: { [key: string]: number } = {};\n  private lastMax: { [key: string]: number } = {};\n  private lastValue: { [key: string]: number } = {};\n  private prevTextTime: number;\n\n  private readonly VSYNC_RATES: VSyncInfo[] = [\n    { refreshRate: 60, frameTime: 16.67 },\n    { refreshRate: 75, frameTime: 13.33 },\n    { refreshRate: 90, frameTime: 11.11 },\n    { refreshRate: 120, frameTime: 8.33 },\n    { refreshRate: 144, frameTime: 6.94 },\n    { refreshRate: 165, frameTime: 6.06 },\n    { refreshRate: 240, frameTime: 4.17 }\n  ];\n  private detectedVSync: VSyncInfo | null = null;\n  private frameTimeHistory: number[] = [];\n  private readonly HISTORY_SIZE = 120; // 2 seconds worth of frames at 60fps\n  private readonly VSYNC_THRESHOLD = 0.05; // 5% tolerance\n  private lastFrameTime: number = 0;\n\n\n\n  static Panel = Panel;\n\n  constructor({\n    trackGPU = false,\n    trackCPT = false,\n    trackHz = false,\n    logsPerSecond = 4,\n    graphsPerSecond = 30,\n    samplesLog = 40,\n    samplesGraph = 10,\n    precision = 2,\n    minimal = false,\n    horizontal = true,\n    mode = 0\n  }: StatsOptions = {}) {\n    this.mode = mode;\n    this.horizontal = horizontal;\n    this.minimal = minimal;\n    this.trackGPU = trackGPU;\n    this.trackCPT = trackCPT;\n    this.trackHz = trackHz;\n    this.samplesLog = samplesLog;\n    this.samplesGraph = samplesGraph;\n    this.precision = precision;\n    this.logsPerSecond = logsPerSecond;\n    this.graphsPerSecond = graphsPerSecond;\n    const prevGraphTime = performance.now();\n    this.prevGraphTime = prevGraphTime\n\n    // Initialize DOM\n    this.dom = document.createElement('div');\n    this.initializeDOM();\n\n    // Initialize timing\n    this.beginTime = performance.now();\n    this.prevTextTime = this.beginTime;\n\n    this.prevCpuTime = this.beginTime;\n\n    this._panelId = 0\n    // Create panels\n    this.fpsPanel = this.addPanel(new Stats.Panel('FPS', '#0ff', '#002'));\n    this.msPanel = this.addPanel(new Stats.Panel('CPU', '#0f0', '#020'));\n\n    if (this.trackHz === true) {\n      this.vsyncPanel = new PanelVSync('', '#f0f', '#202');\n      this.dom.appendChild(this.vsyncPanel.canvas);\n      this.vsyncPanel.setOffset(56, 35);\n    }\n\n    this.setupEventListeners();\n  }\n\n\n  private initializeDOM(): void {\n    this.dom.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      opacity: 0.9;\n      z-index: 10000;\n      ${this.minimal ? 'cursor: pointer;' : ''}\n    `;\n  }\n\n  private setupEventListeners(): void {\n    if (this.minimal) {\n      this.dom.addEventListener('click', this.handleClick);\n      this.showPanel(this.mode);\n    } else {\n      window.addEventListener('resize', this.handleResize);\n    }\n  }\n\n  private handleClick = (event: MouseEvent): void => {\n    event.preventDefault();\n    this.showPanel(++this.mode % this.dom.children.length);\n  };\n\n  private handleResize = (): void => {\n    this.resizePanel(this.fpsPanel);\n    this.resizePanel(this.msPanel);\n    if (this.gpuPanel) this.resizePanel(this.gpuPanel);\n    if (this.gpuPanelCompute) this.resizePanel(this.gpuPanelCompute);\n  };\n\n  public async init(\n    canvasOrGL: WebGL2RenderingContext | HTMLCanvasElement | OffscreenCanvas | any\n  ): Promise<void> {\n    if (!canvasOrGL) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n\n    if (this.handleThreeRenderer(canvasOrGL)) return;\n    if (await this.handleWebGPURenderer(canvasOrGL)) return;\n\n    if (this.initializeWebGL(canvasOrGL)) {\n      if (this.trackGPU) {\n        this.initializeGPUTracking();\n      }\n      return;\n    } else {\n      console.error('Stats-gl: Failed to initialize WebGL context');\n    }\n  }\n\n  private handleThreeRenderer(renderer: any): boolean {\n    if (renderer.isWebGLRenderer && !this.threeRendererPatched) {\n      this.patchThreeRenderer(renderer);\n      this.gl = renderer.getContext();\n\n      if (this.trackGPU) {\n        this.initializeGPUTracking();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  private async handleWebGPURenderer(renderer: any): Promise<boolean> {\n    if (renderer.isWebGPURenderer) {\n      if (this.trackGPU || this.trackCPT) {\n        renderer.backend.trackTimestamp = true;\n        if (await renderer.hasFeatureAsync('timestamp-query')) {\n          this.initializeWebGPUPanels();\n        }\n      }\n      this.info = renderer.info;\n      this.patchThreeWebGPU(renderer);\n      return true;\n    }\n    return false;\n  }\n\n  private initializeWebGPUPanels(): void {\n    if (this.trackGPU) {\n      this.gpuPanel = this.addPanel(new Stats.Panel('GPU', '#ff0', '#220'));\n    }\n    if (this.trackCPT) {\n      this.gpuPanelCompute = this.addPanel(new Stats.Panel('CPT', '#e1e1e1', '#212121'));\n    }\n  }\n\n  private initializeWebGL(\n    canvasOrGL: WebGL2RenderingContext | HTMLCanvasElement | OffscreenCanvas\n  ): boolean {\n    if (canvasOrGL instanceof WebGL2RenderingContext) {\n      this.gl = canvasOrGL;\n    } else if (\n      canvasOrGL instanceof HTMLCanvasElement ||\n      canvasOrGL instanceof OffscreenCanvas\n    ) {\n      this.gl = canvasOrGL.getContext('webgl2');\n      if (!this.gl) {\n        console.error('Stats: Unable to obtain WebGL2 context.');\n        return false;\n      }\n    } else {\n      console.error(\n        'Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.'\n      );\n      return false;\n    }\n    return true;\n  }\n\n  private initializeGPUTracking(): void {\n    if (this.gl) {\n      this.ext = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n      if (this.ext) {\n        this.gpuPanel = this.addPanel(new Stats.Panel('GPU', '#ff0', '#220'));\n      }\n    }\n  }\n\n  public begin(): void {\n    this.beginProfiling('cpu-started');\n\n    if (!this.gl || !this.ext) return;\n\n    if (this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n    }\n\n    this.activeQuery = this.gl.createQuery();\n    if (this.activeQuery) {\n      this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);\n    }\n  }\n\n  public end(): void {\n    this.renderCount++;\n    if (this.gl && this.ext && this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      this.gpuQueries.push({ query: this.activeQuery });\n      this.activeQuery = null;\n    }\n\n    this.endProfiling('cpu-started', 'cpu-finished', 'cpu-duration');\n  }\n\n  public update(): void {\n\n\n    this.endProfiling('cpu-started', 'cpu-finished', 'cpu-duration');\n\n    if (!this.info) {\n      this.processGpuQueries();\n    } else {\n      this.processWebGPUTimestamps();\n    }\n\n    this.updateAverages()\n    this.resetCounters();\n  }\n\n  private processWebGPUTimestamps(): void {\n    this.totalGpuDuration = this.info!.render.timestamp;\n    this.totalGpuDurationCompute = this.info!.compute.timestamp;\n  }\n\n  private resetCounters(): void {\n    this.renderCount = 0;\n    this.totalCpuDuration = 0;\n    this.beginTime = this.endInternal();\n  }\n\n  resizePanel(panel: Panel) {\n\n    panel.canvas.style.position = 'absolute';\n\n    if (this.minimal) {\n\n      panel.canvas.style.display = 'none';\n\n    } else {\n\n      panel.canvas.style.display = 'block';\n      if (this.horizontal) {\n        panel.canvas.style.top = '0px';\n        panel.canvas.style.left = panel.id * panel.WIDTH / panel.PR + 'px';\n      } else {\n        panel.canvas.style.left = '0px';\n        panel.canvas.style.top = panel.id * panel.HEIGHT / panel.PR + 'px';\n\n      }\n    }\n\n  }\n  addPanel(panel: Panel) {\n\n    if (panel.canvas) {\n\n      this.dom.appendChild(panel.canvas);\n      panel.id = this._panelId;\n      this.resizePanel(panel);\n\n      this._panelId++;\n    }\n\n    return panel;\n\n  }\n\n  showPanel(id: number) {\n\n    for (let i = 0; i < this.dom.children.length; i++) {\n      const child = this.dom.children[i] as HTMLElement;\n\n      child.style.display = i === id ? 'block' : 'none';\n\n    }\n\n    this.mode = id;\n\n  }\n\n  processGpuQueries() {\n\n\n    if (!this.gl || !this.ext) return;\n\n    this.totalGpuDuration = 0;\n\n    this.gpuQueries.forEach((queryInfo, index) => {\n      if (this.gl) {\n        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n\n        if (available && !disjoint) {\n          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n          const duration = elapsed * 1e-6;  // Convert nanoseconds to milliseconds\n          this.totalGpuDuration += duration;\n          this.gl.deleteQuery(queryInfo.query);\n          this.gpuQueries.splice(index, 1);  // Remove the processed query\n        }\n      }\n    });\n\n  }\n  private detectVSync(currentTime: number): void {\n    if (this.lastFrameTime === 0) {\n      this.lastFrameTime = currentTime;\n      return;\n    }\n\n    // Calculate frame time\n    const frameTime = currentTime - this.lastFrameTime;\n    this.lastFrameTime = currentTime;\n\n    // Add to histories\n    this.frameTimeHistory.push(frameTime);\n    if (this.frameTimeHistory.length > this.HISTORY_SIZE) {\n      this.frameTimeHistory.shift();\n    }\n\n    // Only start detection when we have enough samples\n    if (this.frameTimeHistory.length < 60) return;\n\n    // Calculate average frame time\n    const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b) / this.frameTimeHistory.length;\n\n    // Calculate frame time stability (standard deviation)\n    const variance = this.frameTimeHistory.reduce((acc, time) =>\n      acc + Math.pow(time - avgFrameTime, 2), 0) / this.frameTimeHistory.length;\n    const stability = Math.sqrt(variance);\n\n    // Only proceed if frame timing is relatively stable\n    if (stability > 2) { // 2ms stability threshold\n      this.detectedVSync = null;\n      return;\n    }\n\n    // Find the closest VSync rate based on frame time\n    let closestMatch: VSyncInfo | null = null;\n    let smallestDiff = Infinity;\n\n    for (const rate of this.VSYNC_RATES) {\n      const diff = Math.abs(avgFrameTime - rate.frameTime);\n      if (diff < smallestDiff) {\n        smallestDiff = diff;\n        closestMatch = rate;\n      }\n    }\n\n    if (closestMatch && (smallestDiff / closestMatch.frameTime <= this.VSYNC_THRESHOLD)) {\n      this.detectedVSync = closestMatch;\n    } else {\n      this.detectedVSync = null;\n    }\n\n  }\n\n  endInternal() {\n    const currentTime = performance.now();\n\n    this.frameTimes.push(currentTime);\n\n    // Remove frames older than 1 second\n    while (this.frameTimes.length > 0 && this.frameTimes[0] <= currentTime - 1000) {\n      this.frameTimes.shift();\n    }\n\n    // Calculate FPS based on frames in the last second\n    const fps = Math.round(this.frameTimes.length);\n\n    this.addToAverage(fps, this.averageFps);\n\n    const shouldUpdateText = currentTime >= this.prevTextTime + 1000 / this.logsPerSecond;\n    const shouldUpdateGraph = currentTime >= this.prevGraphTime + 1000 / this.graphsPerSecond;\n\n    this.updatePanelComponents(this.fpsPanel, this.averageFps, 0, shouldUpdateText, shouldUpdateGraph);\n    this.updatePanelComponents(this.msPanel, this.averageCpu, this.precision, shouldUpdateText, shouldUpdateGraph);\n    if (this.gpuPanel) {\n      this.updatePanelComponents(this.gpuPanel, this.averageGpu, this.precision, shouldUpdateText, shouldUpdateGraph);\n    }\n    if (this.trackCPT && this.gpuPanelCompute) {\n      this.updatePanelComponents(this.gpuPanelCompute, this.averageGpuCompute, this.precision, shouldUpdateText, shouldUpdateGraph);\n    }\n\n    if (shouldUpdateText) {\n      this.prevTextTime = currentTime;\n    }\n    if (shouldUpdateGraph) {\n      this.prevGraphTime = currentTime;\n    }\n\n    if (this.vsyncPanel !== null) {\n      this.detectVSync(currentTime);\n\n      const vsyncValue = this.detectedVSync?.refreshRate || 0;\n\n      if (shouldUpdateText && vsyncValue > 0) {\n        this.vsyncPanel.update(vsyncValue, vsyncValue);\n      }\n    }\n\n    return currentTime;\n  }\n\n  private updatePanelComponents(\n    panel: Panel | null,\n    averageArray: { logs: number[], graph: number[] },\n    precision: number,\n    shouldUpdateText: boolean,\n    shouldUpdateGraph: boolean\n  ) {\n    if (!panel || averageArray.logs.length === 0) return;\n\n    // Initialize tracking for this panel if not exists\n    if (!(panel.name in this.lastMin)) {\n      this.lastMin[panel.name] = Infinity;\n      this.lastMax[panel.name] = 0;\n      this.lastValue[panel.name] = 0;\n    }\n\n    const currentValue = averageArray.logs[averageArray.logs.length - 1];\n\n    this.lastMax[panel.name] = Math.max(...averageArray.logs);\n    this.lastMin[panel.name] = Math.min(this.lastMin[panel.name], currentValue);\n    // Smooth the display value\n    this.lastValue[panel.name] = this.lastValue[panel.name] * 0.7 + currentValue * 0.3;\n\n    // Calculate graph max considering both recent values and graph history\n    const graphMax = Math.max(\n      Math.max(...averageArray.logs),\n      ...averageArray.graph.slice(-this.samplesGraph)\n    );\n\n    this.updateCounter++;\n\n    // Update text if it's time\n    if (shouldUpdateText) {\n      panel.update(\n        this.lastValue[panel.name],\n        this.lastMax[panel.name],\n        precision\n      );\n    }\n\n    // Update graph if it's time\n    if (shouldUpdateGraph) {\n      panel.updateGraph(\n        currentValue,\n        graphMax\n      );\n    }\n  }\n\n  private beginProfiling(marker: string): void {\n    if (window.performance) {\n      try {\n        window.performance.clearMarks(marker);\n        window.performance.mark(marker);\n      } catch (error) {\n        console.debug('Stats: Performance marking failed:', error);\n      }\n    }\n  }\n\n  private endProfiling(startMarker: string | PerformanceMeasureOptions | undefined, endMarker: string | undefined, measureName: string): void {\n    if (!window.performance || !endMarker || !startMarker) return;\n\n    try {\n      // First check if the start mark exists\n      const entries = window.performance.getEntriesByName(startMarker as string, 'mark');\n      if (entries.length === 0) {\n        // If start mark doesn't exist, create it now with the same timestamp as end\n        this.beginProfiling(startMarker as string);\n      }\n\n      // Create the end mark\n      window.performance.clearMarks(endMarker);\n      window.performance.mark(endMarker);\n\n      // Clear any existing measure with the same name\n      window.performance.clearMeasures(measureName);\n\n      // Create the measurement\n      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);\n      this.totalCpuDuration += cpuMeasure.duration;\n\n      // Clean up\n      window.performance.clearMarks(startMarker as string);\n      window.performance.clearMarks(endMarker);\n      window.performance.clearMeasures(measureName);\n    } catch (error) {\n      console.debug('Stats: Performance measurement failed:', error);\n    }\n  }\n\n  updatePanel(panel: { update: any; updateGraph: any; name: string; } | null, averageArray: { logs: number[], graph: number[] }, precision = 2) {\n    if (!panel || averageArray.logs.length === 0) return;\n\n    const currentTime = performance.now();\n\n    // Initialize tracking for this panel if not exists\n    if (!(panel.name in this.lastMin)) {\n      this.lastMin[panel.name] = Infinity;\n      this.lastMax[panel.name] = 0;\n      this.lastValue[panel.name] = 0;\n    }\n\n    // Get the current value and recent max\n    const currentValue = averageArray.logs[averageArray.logs.length - 1];\n    const recentMax = Math.max(...averageArray.logs.slice(-30));\n\n    // Update running statistics\n    this.lastMin[panel.name] = Math.min(this.lastMin[panel.name], currentValue);\n    this.lastMax[panel.name] = Math.max(this.lastMax[panel.name], currentValue);\n\n    // Smooth the display value\n    this.lastValue[panel.name] = this.lastValue[panel.name] * 0.7 + currentValue * 0.3;\n\n    // Calculate graph scaling value\n    const graphMax = Math.max(recentMax, ...averageArray.graph.slice(-this.samplesGraph));\n\n    this.updateCounter++;\n\n    // Reset min/max periodically\n    if (this.updateCounter % (this.logsPerSecond * 2) === 0) {\n      this.lastMax[panel.name] = recentMax;\n      this.lastMin[panel.name] = currentValue;\n    }\n\n    if (panel.update) {\n      // Check if it's time to update the text (based on logsPerSecond)\n      if (currentTime >= this.prevCpuTime + 1000 / this.logsPerSecond) {\n        panel.update(\n          this.lastValue[panel.name],\n          currentValue,\n          this.lastMax[panel.name],\n          graphMax,\n          precision\n        );\n      }\n\n      // Check if it's time to update the graph (based on graphsPerSecond)\n      if (currentTime >= this.prevGraphTime + 1000 / this.graphsPerSecond) {\n        panel.updateGraph(\n          currentValue,\n          graphMax\n        );\n        this.prevGraphTime = currentTime;\n      }\n    }\n  }\n\n  private updateAverages(): void {\n\n    this.addToAverage(this.totalCpuDuration, this.averageCpu);\n    this.addToAverage(this.totalGpuDuration, this.averageGpu);\n    // Add GPU Compute to the main update flow\n    if (this.info && this.totalGpuDurationCompute !== undefined) {\n      this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n    }\n  }\n\n  addToAverage(value: number, averageArray: { logs: any; graph: any; }) {\n    // Validate value\n    // if (value === undefined || value === null || isNaN(value) || value === 0) {\n    //   return;\n    // }\n\n    // Store raw values for logs\n    averageArray.logs.push(value);\n    if (averageArray.logs.length > this.samplesLog) {\n      averageArray.logs = averageArray.logs.slice(-this.samplesLog);\n    }\n\n    // For graph, store raw values\n    averageArray.graph.push(value);\n    if (averageArray.graph.length > this.samplesGraph) {\n      averageArray.graph = averageArray.graph.slice(-this.samplesGraph);\n    }\n  }\n\n  get domElement() {\n    // patch for some use case in threejs\n    return this.dom;\n\n  }\n\n  patchThreeWebGPU(renderer: any) {\n\n    const originalAnimationLoop = renderer.info.reset\n\n    const statsInstance = this;\n\n    renderer.info.reset = function () {\n\n      statsInstance.beginProfiling('cpu-started');\n\n      originalAnimationLoop.call(this);\n\n    }\n\n  }\n\n  patchThreeRenderer(renderer: any) {\n\n    // Store the original render method\n    const originalRenderMethod = renderer.render;\n\n    // Reference to the stats instance\n    const statsInstance = this;\n\n    // Override the render method on the prototype\n    renderer.render = function (scene: THREE.Scene, camera: THREE.Camera) {\n\n      statsInstance.begin(); // Start tracking for this render call\n\n      // Call the original render method\n      originalRenderMethod.call(this, scene, camera);\n\n      statsInstance.end(); // End tracking for this render call\n\n    };\n\n\n    this.threeRendererPatched = true;\n\n  }\n}\n\n\nexport default Stats;\n"],
  "mappings": "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",
  "names": ["_Stats"]
}
